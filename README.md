# 🔐 纯客户端图片加密套件 (Client-Side Image Encryption Suite)

![Project Status](https://img.shields.io/badge/status-active-success)
![Version](https://img.shields.io/badge/version-2.0-blue)
![License](https://img.shields.io/badge/license-MIT-green)

本项目是一个高级的、纯客户端（浏览器端）运行的图片加密解决方案。它确保您的图片和密码**永远不会离开您的设备**，所有加密和解密操作均在本地浏览器中完成，为您的数字隐私提供100%的安全保障。

---

## 🚀 访问入口：双界面，同一核心

本项目的一大特色是提供了两个**界面不同、但加密核心完全相同**的在线工具。您可以选择任意一个使用，它们的数据是**100% 互通**的。

### 1. 访问点 A (主界面 / `index.html`)

* **链接:** **[https://yiranrumengqaq.github.io/Bate/](https://yiranrumengqaq.github.io/Bate/)**
* **描述:** 这是项目的主访问界面，使用响应式布局，适配 PC 和移动端，并包含一个详细的日志查看器。

### 2. 访问点 B (备用界面 / `ImageEncryptor.html`)

* **链接:** **[https://yiranrumengqaq.github.io/Bate/ImageEncryptor.html](https://yiranrumengqaq.github.io/Bate/ImageEncryptor.html)**
* **描述:** 这是一个界面布局不同的备用版本，同样提供了完整的加密解密功能，展示了同一加密引擎的不同“皮肤”。

---

## 🔑 核心特性：完全互通性

本项目最关键的设计在于**加密/解密的互通性**。

无论您使用 `访问点 A` 还是 `访问点 B`，它们都共享**完全相同的加密协议**和**密码派生算法**。

这意味着：

* **场景一:** 您在 `网站 A` 使用密码 `123` 加密了图片，下载后。
* **场景二:** 您可以将这张加密图片上传到 `网站 B`，输入相同的密码 `123`，**可以完美解密**。
* **反之亦然:** 在 `网站 B` 加密的图片，也完全可以在 `网站 A` 解密。

这种设计允许用户根据偏好自由选择界面，而无需担心数据兼容性问题。

---

## ✨ 更多功能

* **零服务器依赖:** 纯粹的 HTML/CSS/JavaScript 应用。您的数据**永远不会**被上传到任何服务器。
* **确定性加密:** 相同的图片和相同的密码，将**始终**产生相同的加密结果。
* **响应式设计:** 完美适配桌面电脑 (PC) 和移动设备 (PE) 浏览器。
* **拖拽支持:** 现代化的拖放文件上传界面。
* **实时预览:** 加密/解密后即时在画布上显示结果，提供直观反馈。
* **操作日志 (仅限主界面):** `index.html` 版本提供了一个详细的日志系统，用于跟踪每一步操作，便于调试和理解流程。

---

## 💡 工作原理：加密协议详解

本工具的安全性基于一个多层、确定性的混淆协议。解密是该协议的精确逆向操作。

### 第 1 步：密钥派生 (Key Derivation)
我们不直接使用您的明文密码。相反，输入的密码字符串会通过一个确定性的 `hashPassword` 函数（类 djb2 算法）处理，生成一个唯一的32位整数。这个整数将作为所有后续伪随机操作的**主种子 (Master Seed)**。

### 第 2 步：像素置换 (Pixel Permutation)
为了彻底破坏图像的结构，我们首先对像素位置进行打乱。
* 算法使用“主种子”，基于一个可复现的伪随机数生成器（类 LCG），对整个图像的像素阵列执行**三重 Fisher-Yates 随机置换**。
* 这会将每个像素（连同其 Alpha 通道）移动到一个新的、看似随机的位置。只有拥有**完全相同的主种子**，才能逆向此过程，将像素放回原位。

### 第 3 步：颜色混淆 (Color Obfuscation)
在像素位置被打乱后，我们对每个像素的 `R` (红), `G` (绿), `B` (蓝) 通道值进行加密。
* 算法使用“主种子”和“当前像素索引”派生出一组新的加密密钥。
* 每个颜色通道都会经过**多重位异或 (Bitwise XOR)** 和**模加法 (Modular Addition)** 运算。
* 这会使图像的颜色数据完全失真，变成一片无法识别的噪点（雪花图）。

### 第 4 步：注入识别标记 (Header Injection)
加密完成后，一个特定的魔法头字符串 (`ENC_IMG_V1_`) 会被注入到最终生成的 PNG 文件的 Base64 数据中。这使得工具在加载文件时，能**立即识别**出这是一个加密文件，从而提示用户输入密码解密。

---

## ⚠️ 安全与隐私声明 (必读)

1.  **隐私绝对安全:**
    本工具是**100% 纯客户端**应用。您的图片和密码**永远不会**离开您的浏览器，不会被发送到任何服务器。所有处理均在您的本地设备上实时完成。

2.  **安全级别定义:**
    本工具提供的是**视觉混淆**和**轻量级加密**。它的主要目的是防止**未经授权的随意查看**（例如，他人浏览您的相册或网盘）。它**不能**替代 AES-256 等重量级金融/军事级加密标准，请勿用于涉及极端国家安全的场景。

3.  **密码丢失 = 数据丢失:**
    解密过程**完全依赖**于您加密时设置的原始密码。由于哈希函数的单向性，**如果密码遗忘，加密后的图片将永远无法恢复！** 本系统没有“找回密码”功能。**请务必妥善保管您的密码！**

---

## 🛠️ 技术栈

* **HTML5:**
    * `Canvas API`: 用于读取和写入像素数据 (`getImageData` / `putImageData`)。
* **CSS3:**
    * `Flexbox` & `Grid`: 用于构建灵活且响应式的布局。
    * `Media Queries`: 适配 PC 和移动端。
* **JavaScript (ES6+):**
    * `FileReader API`: 异步读取本地文件。
    * `Typed Arrays`: 高效处理画布的 `ImageData` (Uint8ClampedArray)。
    * **核心加密/哈希算法。**

